<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入浅出极大似然估计]]></title>
    <url>%2F2019%2F04%2F04%2F20190404_likelihood%2F</url>
    <content type="text"><![CDATA[之前多次接触极大似然估计，一直没有透彻的理解清楚，下午特意抽空查阅资料，整理成一篇较为通俗易懂的博文。 概念 “似然” ( likelihood )可以通俗的理解成 ”像是这样“ ，意思为 ”事件(观察数据)发生的可能性“，”极大似然估计“ 就是要找到一个估计值，使得 ”事件发生的可能性“ 最大。 举个例子 如图，有两个外形完全相同的箱子。甲箱中有99个白球1个黑球，乙箱中有99个黑球1个白球。一次试验，取出的是黑球。 那么这个黑球最像是从哪个箱子取出的？ 大多数人都会说，这个黑球最像是从乙箱中取出的，这个推断符合人们的经验，即为“最大似然”。 总结来说，最大似然估计 假设模型是确定的，然后利用抽取的样本结果，反推最大概率导致这样结果的模型参数值，即：“模型已定，参数未知”。 因此，样本结果的概率(即事件发生的可能性)，是一个带模型参数的似然函数。最大似然估计法的目标就是最大化似然函数，用最优化算法求解 导致样本结果概率最大的参数值。 极大似然估计的描述 极大似然估计中采样需满足一个很重要的假设，就是所有的采样都是独立同分布的。 首先，假设$ x_1,x_2,…,x_n$为独立同分布的采样，θ为模型参数, f 为所使用的模型。因此，产生上述采样结果的概率可表示为： $$f(x_1,x_2,…,x_n|\theta) = f(x_1|\theta)*f(x_2|\theta)…,f(x_n|\theta)$$ 由于极大似然估计法中，我们已知的为$ x_1,x_2,…,x_n$，未知为θ，故似然函数定义为: $$L(\theta|x_1,…,x_n) = f(x_1,…,x_n|\theta)=\prod_{i=1}^{n}f(x_i|\theta)$$ 两边取对数，得到对数似然，公式为： $$ln L(\theta|x_1,…,x_n) = ln \prod_{i=1}^{n}f(x_i|\theta) = \sum_{i=1}^nln f(x_i|\theta)$$ 最大似然估计法最常用的为对数平均似然，公式为： $$\hat{l} = \frac1{n}\ln L(\theta|x_1,…,x_n)$$ 因此最大似然估计法就是 最大化似然函数求参数值，即：$$\hat{\theta}_{mle} =\theta\in \Theta\hat{l}(\theta\lvert x_1,…,x_n)$$ 极大似然估计的例子 我们假设已知的模型为正态分布$N(\mu,\sigma^2)$，则似然函数为： $$L(\mu,\sigma^2)=\prod_{i=1}^{n}f(x_i|\theta)=\prod_{i=1}^{n}\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x_i-\mu)^2}{2\sigma^2}} =(2\pi\sigma^2)^{-\frac{n}{2}}e^{-\frac1{2\sigma^2}\sum_{i=1}^n(x_i-\mu)^2}$$ 两边取对数，得对数似然函数为： $$ln L(\mu,\sigma^2)=-\frac{n}{2}ln(2\pi)-\frac{n}{2}ln(\sigma^2)-\frac1{2\sigma^2}\sum_{i=1}^n(x_i-\mu)^2$$ 最大化似然函数，我们对它进行求导： $$ \begin{cases} \frac{\partial\ln L(\mu,\sigma^2)}{\partial\mu}=\frac1{\sigma^2}\sum_{i=1}^{n}(x_i-\mu) =0 \\ \frac{\partial\ln L(\mu,\sigma^2)}{\partial\sigma^2}=-\frac{n}{2\sigma^2}+\frac1{2\sigma^4}\sum_{i=1}^{n}(x_i-\mu)^2 =0 \end{cases}$$ 联合解得：$$ \begin{cases} \mu=\overline{x}=\frac1{n}\sum_{i=1}^{n}x_i \\ \sigma^{2}=\frac1{n}\sum_{i=1}^n(x_i-\overline{x})^2 \end{cases}$$ 似然方程有唯一解：$(\mu,\sigma^{2})$,即为最大似然估计量$ \hat{\theta} $。 因此，求最大似然估计量$\hat{\theta}$的一般步骤为： （1）写出似然函数； （2）对似然函数取对数，并整理； （3）求导数； （4）解似然方程。 注意： 参数估计不同于估计。 日常所说的估计一般是通过样本分布估计总体的分布，比如用样本集的均值作为总体的期望。在参数估计中，模型是假设已知的，估计得参数后就可得完整模型。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>数学统计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《利用Python进行数据分析》之pandas的时间序列基础]]></title>
    <url>%2F2019%2F03%2F18%2F20190318_pandas_timeseries%2F</url>
    <content type="text"><![CDATA[本章以《利用python进行数据分析》的第10章：时间序列 为基础，整理了pandas 库中时间序列相关用法。时间序列数据的意义取决于具体的应用场景，主要有以下几种： 时间戳(timestamp) 固定时期(period) 时间间隔(interval) 实验或过程时间 pandas提供了一组标准的时间序列处理工具和算法，可以轻松的对时间序列进行切片、聚合，对定期/不定期的时间序列进行重采样等。这些工具大部分对金融和经济数据尤为有用，同时也可以用来分析服务器和日志数据。 1.日期和时间数据类型及工具python标准库包含用于日期(date)和时间(time)的数据类型，主要用到datetime、time、calendar等模块。 datetime模块datetime模块中的数据类型 date :以公历形式存储日期 （年月日） time :将时间存储为时、分、秒、毫秒 datetime :存储日期和时间 timedelta :表示两个datetime值之间的差 (日、秒、毫秒) (1)datetime .now()函数，返回一个当前时间的datetime类型 datetime类型 有 .year ,.month , .day等属性 123456import pandas as pdfrom pandas import Seriesfrom pandas import DataFramefrom datetime import datetimenow=datetime.now()now.year,now.month,now.day (2019, 3, 18) (2)timedelta timedelta表示两个datetime对象之间的时间差 有 .days , .seconds 等属性 123delta = datetime(2019,3,18)-datetime(2019,1,1,8,15)delta.daysdelta.seconds 56700 可以给datetime对象加上（减去）一个或者多个timedelta，则产生一个新对象 1234567from datetime import timedeltastart=datetime(2019,1,1)start=start+timedelta(75)start1=start-2*timedelta(75)startprint (start)print (start1) 2019-03-17 00:00:00 2018-10-18 00:00:00 (3)字符串和datetime的相互转换datetime类型或者timestamp 类型 –&gt; 字符串类型 str()函数 datetime的.strftime(‘%y-%m-%d’)方法 ,其中格式化编码表格在P306 12345stamp=datetime(2019,1,1)str1=str(stamp)str2=stamp.strftime('%Y-%m-%d %H:%M:%S')print (str1)print (str2) 2019-01-01 00:00:00 2019-01-01 00:00:00 字符串类型 –&gt; datetime类型或者timestamp 类型 datetime的.strptime方法 123value='2019-01-01'd1=datetime.strptime(value,'%Y-%m-%d')print (d1) 2019-01-01 00:00:00 其中，是通过已知格式进行日期解析，但是编写格式定义比较麻烦可以通过dateutil这个第三方包中parser.parse方法,可以对格式快速解析 123from dateutil.parser import parseparse('2011-01-01')parse('6/12/2011',dayfirst=True) datetime.datetime(2011, 12, 6, 0, 0) pandas 通常是用于处理成组日期。to_datetime方法可以解析多种不同的日期表示形式 12datestrs=['7/6/2019','8/6/2019']pd.to_datetime(datestrs) DatetimeIndex([&apos;2019-07-06&apos;, &apos;2019-08-06&apos;], dtype=&apos;datetime64[ns]&apos;, freq=None) 2.时间序列基础pandas 最基本的时间序列类型就是以时间戳(python字符串 或datetime对象)为索引的Series当创建一个带有DatatimeIndex的Series时，pandas就会创建一个TimeSeries (1)TimeSeries的创建1234import numpy as npdates=[datetime(2019,1,1),datetime(2019,1,2),datetime(2019,1,3),datetime(2019,1,4)]ts=Series(np.random.randn(4),index=dates)ts 2019-01-01 -0.372832 2019-01-02 0.460571 2019-01-03 0.488445 2019-01-04 -0.208852 dtype: float64 (2)TimeSeries的索引、切片TimeSeries是Series的一个子类，所以其索引切片都很类似 1.索引1ts.index[2] Timestamp(&apos;2019-01-03 00:00:00&apos;) 12ts[ts.index[2]]ts[datetime(2019,1,2)] 0.4605713788911559 2.切片可以传入字符串日期、datetime、timestamp切片的是源数据的视图，与numpy的数组切片运算是一样的。 1ts['2019-01-02':'2019-01-04'] 2019-01-02 0.460571 2019-01-03 0.488445 2019-01-04 -0.208852 dtype: float64]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据可视化之Matplotlib:Pandas中的绘图函数]]></title>
    <url>%2F2019%2F03%2F15%2F20190315-python-pandas-matplotlib%2F</url>
    <content type="text"><![CDATA[Pandas有许多能够利用DataFrame对象数据组织特点来创建标准图表的高级绘图方法，本文主要介绍的是pandas中的绘图函数。 12345#coding:utf-8import matplotlib.pyplot as pltimport pandas as pdimport numpy as npfrom pandas import DataFrame,Series 1. 线形图&emsp;df.plot( kind=&#39;line&#39;) Series 的plot 方法会以index作为X轴,画一条线 DataFrame 的plot 方法会以index作为X轴，给每一列绘制一条线,columns作为图例。 12345678910111213141516#第一种创建画布和画布分区方法，分开创建figure和subplot对象fig=plt.figure()#Series 的线形图ax1=fig.add_subplot(2,1,1)s=Series(np.random.rand(10).cumsum(),index=np.arange(0,100,10)) s.plot( kind='line')plt.xlabel(u"index") plt.title(u"Serise的线形图")plt.show()#DataFrame的线形图ax2=fig.add_subplot(2,1,2)df=DataFrame(np.random.rand(10,4).cumsum(0),index=np.arange(0,100,10),columns=pd.Index(['A','B','C','D'],name='Genus'))df.plot( kind='line')plt.xlabel(u"index") plt.title(u"DataFrame的线形图")plt.show() 其中，Series.plot方法的参数 kind ：图的类型，‘line’,’bar’,’barh’,’kde’ label ：图例标签 ax ：需要绘制的对象 rot ：旋转角度 xticks ：X轴刻度值 xlim ：X轴刻度范围 grid ：显示网格 2. 柱状图&emsp;df.plot( kind=&#39;bar&#39;) : 垂直柱状图 &emsp;df.plot( kind=&#39;barh&#39;) : 水平柱状图 &emsp;df.plot( kind=&#39;bar&#39;,stacked=True) : stacked属性为True可以设置为堆积柱状图 Series的柱状图123456#第二种创建画布和画布分区方法，创建figure，返回一个subplot对象fig,axes =plt.subplots(2,1) s=Series(np.random.rand(16),index=list('abcdefghijklmnop')) s.plot( kind= 'bar' ,ax=axes[0]) #返回的axes的数组可指定在哪个subplot对象上画图s.plot( kind= 'barh' ,ax=axes[1]) plt.show() DataFrame的柱状图 每一行的值为一组，每一列的columns为图例 12345fig,axes =plt.subplots(2,1) df=DataFrame(np.random.rand(4,4),index=['one','two','three','four'],columns=pd.Index(['A','B','C','D'],name='Genus')) df.plot( kind= 'bar',ax=axes[0] ) df.plot( kind= 'bar',ax=axes[1],stacked=True ) #stacked=True 可以生成堆积柱状图plt.show() 3.密度图( KDE, Kernel Density Estimate ,核密度估计 ) 密度图即为连续概率分布图，将分布近似为标准混合正态分布。 &emsp;df.plot( kind=&#39;kde&#39;) 1234567891011121314fig=plt.figure()#Series 的密度图fig.add_subplot(2,1,1)s=Series(np.random.rand(50).cumsum(),index=np.arange(0,100,2)) s.plot(kind='kde')plt.title(u"Series的密度图")plt.show()#DataFrame 的密度图，会给每一列都画一条密度估计线，并将columns自动生成图例fig.add_subplot(2,1,2)df=DataFrame(np.random.rand(10,4).cumsum(0),index=np.arange(0,100,10),columns=pd.Index(['A','B','C','D'],name='Genus'))df.plot(kind='kde')plt.title(u"DataFrame的密度图")plt.show() 4.直方图 直方图是对值频率进行离散化显示的柱状图，数据点呗拆分到离散的、间隔均匀的面元中。 &emsp;df.hist( bins=10) :bins属性可设置柱子数量 12345678910111213fig=plt.figure()#Series 的密度图fig.add_subplot(2,1,1)s=Series(np.random.rand(20).cumsum(),index=np.arange(0,100,5)) s.hist( bins=10)plt.title(u"Series的直方图")plt.show()#DataFrame 的密度图，会给每一列都画一张直方图，并将列名作为对应标题fig.add_subplot(2,1,2)df=DataFrame(np.random.rand(10,4).cumsum(0),index=np.arange(0,100,10),columns=pd.Index(['A','B','C','D'],name='Genus'))df.hist( bins=10)plt.show() 5.散点图 散点图是观察两个一维数据间关系的有效方式 &emsp;plt.scatter(X,Y) 1234567macro = pd.read_csv('macrodata.csv')data = macro[['cpi','m1','tbilrate','unemp']]trans_data = np.log(data).diff().dropna()# 画出两个Series之间的散点图plt.scatter(trans_data['m1'],trans_data['unemp'])plt.title('Change in log %s vs.log %s' % ('m1','unemp'))plt.show() DataFrame的散点图矩阵 创建散布图矩阵，会把DataFrame中任意两列画散点图，观察其之间的关系。 支持在对角线上放置各变量的直方图或者密度图 &emsp;pd.scatter_matrix( trans_data ,diagonal = &#39;kde&#39; ,color =&#39;k&#39; ,alpha=0.3) 123# 画出散布图矩阵pd.plotting.scatter_matrix( trans_data ,diagonal = 'kde' ,color ='k' ,alpha=0.3)plt.show()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据可视化</tag>
        <tag>matplotlib</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《利用Python进行数据分析》之pandas基础]]></title>
    <url>%2F2019%2F03%2F15%2F20190315_pandas_syntax%2F</url>
    <content type="text"><![CDATA[本文以《利用python进行数据分析》的第四章：pandas入门为基础，总结了pandas常用的基本语法。 1. Pandas的数据结构1. Series类似于一维数组的对象： 由一组数据（各种numpy对象）和一组与之相关的索引组成。分别有两个属性，.values 和 .index (1)创建Series 直接定义,包括定义index 输入一个dict，转成Series 123456789import pandas as pdfrom pandas import DataFrame,Seriesimport numpy as npfrom numpy import random#直接定义Seriesobj=Series([-4,7,8,9],index=['a','b','c','d'])#用字典创建Seriesdict=&#123;'a':-4,'b':7,'c':8,'d':9&#125;obj1=Series(dict) (2)利用索引查找数据12obj['a']obj[['a','b']] (3)利用布尔型索引过滤数据1obj[obj&gt;0] (4)Series自动对齐不同索引数据 重传index到已有index的Series,或者dict中，则values会自动与index对齐。（找不到values的index,会填充NAN） 1234#在有index的Series传入indexobj1=Series(obj,index=['c','d','e','f']) #在有index的dict传入indexobj2=Series(dict,index=['c','d','e','f']) 2. DataFrame是表格型数据结构，含有一组有序的列，每列可以是不同的值类型。可看作是由一组Series组成(共用同一个索引) (1)创建DataFrame 直接定义,,包括index,columns 输入一个有列表或者numpy数组的dict，转成DataFrame 12345678#直接定义data = [[1,2,3],[4,5,6]]index = [0,1]columns=['a','b','c']df = pd.DataFrame(data=data, index=index, columns=columns)#利用dict转成DataFramedict=&#123;'a':[1,2,3],'b':[4,5,6],'c':[7,8,9]&#125;df1=DataFrame(dict,index=['one','two','three']) (2)利用列名取数据 通过列名或者属性的方式可以从DataFrame获取一组Series 12df1['a']df1.a (3)赋值、创建新列12df1['a']=1df1['d']=4 (4)删除列1del df1['d'] 2.基本功能(1)重新索引 .reindex() 可以重新索引行和列，对数据重新排列。 若索引无对应数据，可以填充插值，插值默认为空.参数method、fill_value分别用于 插值方式和 设置缺失值的替代值 12df2=df1.reindex(index=['two','one','four','three'],columns=['b','c','a','e'],fill_value=22)print (df2) (2)删除某一行或某一列 删除行可以直接写入 index的名字 删除列除了写入columns名，还需要指定axis 12df3=df2.drop('four')df3=df2.drop('e',axis=1) (3) 索引Series的索引可用Index ,也可用数字下标 12345s1=df3['b']s1['two']s1[['two','one']] # 用数组列出，要用[ ]括起来s1['two':'four'] # 标签切片的右区间是闭合的s1[1:3] # 标号切片的右区间是开放的 DataFrame的索引1. 列索引：直接用列的字段名索引 (注意:行索引不能直接用字段名)123df3['b']df3[['b','c']]print (df3) 2..loc 通过标签索引数据 先写行标签，后写列标签 列举多个列，要用数组，用[ ]括起来 列举切片，则无需用[ ]括起来。注意标签切片的右括号是闭合的 123456df3.loc[['two','one']] #索引多行，行名用数组df3.loc['two':'three'] #索引多行，行名用切片df3.loc['two',['b','a']] #索引某行多列，列名用数组df3.loc['two','b':'a'] #索引某行多列，列名用切片df3.loc[:,['b','a']] #索引某列print (df3) 3..iloc 通过标号获取数据 先写行号，再写列号 可用单值，也可用切片，注意：标号切片的右括号是开区间的 1df3.iloc[1:3,1:3] .ix 结合前两者的混合索引,可同时使用标签和行号，注意：目前.ix已弃用 (4)过滤 使用布尔数组来过滤数据 12df33=df3[df3['a']&lt;2] #先用某一列过滤，返回一个布尔数组，然后通过布尔数组再过滤行print (df33) 1df3[df3&lt;2]=0 #选取特定的值重新赋值 (5)计算方法 Series和DataFrame 可以根据 行列索引 自动对齐, 未对齐的默认填充NAN，也可以用fill_value属性，指定填充值 .add() .sub() .div() .mul() (6)DataFrame 和Series 之间的运算 广播 默认 Series的索引，匹配DataFrame的列标签。按行广播 若要 Series的索引，匹配DataFrame的行标签的话，要用axis指定 12s1 = df3.loc['two']s2 = df3['b'] 12345# df4=df3+s1df4=df3.add(s1)print (df3)print (s1)print (df4) 1234df5=df3.add(s2,axis=0) #指定s2的索引是匹配行标签，则是按列广播print (df3)print (s2)print (df5) (7)排序和排名1.根据任意轴索引排序* 默认为按行标签排序，用axis属性可设置需要排序的轴 默认为升序排序，用 ascending 属性可设置升降序 12df3.sort_index() #默认axis=0,按行标签排序df3.sort_index(axis=1,ascending=False) #按列标签排序 2.根据某个列值排序1df3.sort_values(by='b') 3.排名 与排序的区别在于,会增设一个排名值（从1开始），同时会根据某种规则破坏平级关系 可以用method设置不同的排名方式 1df3.rank(axis=0,method='first') # axis=0 为按列排名， axis=1 为按行排名 3.汇总和计算描述统计 NA值会自动排除，skipna可以设置 axis=0 按列计算，axis=1 按行计算 (1)唯一值、值计数、成员资格Series中的方法1.唯一值12obj=Series(['a','a','c','d','e','a','b'])obj.unique() # 返回的是一个nparray 2.值计数12obj1=obj.value_counts() #常用于统计某个离散值各个类别的频率print(obj1) 3.成员资格12obj2=obj.isin(['b','c'])print(obj2) 4.处理缺失数据(1)滤除缺失数据Series的方法12345import numpy as npfrom numpy import nan as NAdata=Series([1,NA,3.5,NA,10])data.dropna() #用.dropna（）的方法data[data.notnull()] #通过布尔索引来过滤 DataFrame的方法 丢弃任何含NA的行 只丢弃全为NA的行 过滤部分，用thresh参数 1234df3['d']=NAdf4=df3.dropna(axis=1) #axis=0 为丢掉所有含NAN的行，axis=1 为丢掉所有含NAN的列df4=df3.dropna(how='all') # how='all'df4=df3.dropna(thresh=2) (2)填充缺失数据 .fillna方法 可对所有缺失值赋值 可用词典对不同的列填充不同的值 默认是返回新对象，可用inplace属性 设置对象就地修改 可用method 属性设置不同的插值方式 12df3['d']=[6,7,8,9]df3.iloc[0:2,2:4]=NA 12df3.fillna(1) #可对所有缺失值赋值df3.fillna(&#123;'a':4,'d':5&#125;) #可用词典对不同的列填充不同的值 5.层次化索引 P1531.Series1.创建层次化索引12data=Series(np.random.randn(6),index=[['a','a','b','b','c','c'],[1,2,1,2,1,2]])print(data) 2.Series层次化索引的切片操作123data['a':'b']data.loc[['a','c']]data.loc[:,2] #类似DataFrame中先选行再选列，在层次化索引中先选外层再选内层 3.层次化索引与DataFrame间的转换12data.unstack() #从层次化索引转换成DataFramedata.unstack().stack() #从DataFrame转换成层次化索引 2.DataFrame1.创建层次化索引 每条轴都可以有分层索引 可以给每个层级的索引命名 .names 123frame=DataFrame(np.arange(12).reshape(4,3),index=[['a','a','b','b'],[1,2,1,2]],columns=[['Ohio','Ohio','Colorado'],['Green','Red','Green']])frame.index.names=['key1','key2']frame.columns.names=['state','color'] 2.重排分级顺序 .swaplevel (序号1，序号2) ：序号为索引层级，从0开始；也可以直接用标签 .sort_index（level=序号） ：对索引进行排序 123frame.swaplevel('key1','key2')# frame.swaplevel('key1','key2').sort_index(level='key2')frame.swaplevel(0,1).sort_index(level=0) 3.将某列作为索引1234frame=DataFrame(&#123;'a':range(7),'b':range(7,0,-1),'c':['one','one','one','two','two','two','two'],'d':[0,1,2,0,1,2,3]&#125;)frame.set_index(['c','d']) #把某列作为行索引，该列从DataFrame中移除frame.set_index(['c','d'],drop=False) #把某列作为行索引，该列在DataFrame中保留frame.reset_index( ) #将层次化索引的级别会转到列里面 4.DataFrame层次化索引的切片操作 列索引可直接用列名索引 行索引若一级索引有多个索引，则二级索引不能直接索引，要转化 1234frame=DataFrame(np.arange(12).reshape(4,3),index=[['a','a','b','b'],[1,2,1,2]],columns=[['Ohio','Ohio','Colorado'],['Green','Red','Green']])frame.index.names=['key1','key2']frame.columns.names=['state','color']frame （1）列索引可以直接用列名 123frame['Ohio'] #取最外层的列标签frame['Ohio','Green'] #取内层的单个列标签frame['Ohio'][['Red','Green']] #取内层的多个列标签,先取外层得出一个DataFrame，再取内层 （2）行索引 要用.loc的方法 注意在对行索引的时候，若一级行索引还有多个，对二级行索引会遇到问题！也就是说，无法直接对二级索引进行索引，必须让二级索引变成一级索引后才能对其进行索引！ 123frame.loc['a'] #取最外层的行标签frame.loc['a',1] #取内层层的单个行标签frame.ix['a',[1,2]] #取内层层的单个行标签 （3）行列一起索引 1frame.loc['a']['Ohio','Green'] #先索引行标签，在基础上取列]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习笔记之逻辑回归原理]]></title>
    <url>%2F2019%2F03%2F14%2Flogistic-fundamental%2F</url>
    <content type="text"><![CDATA[1.从线性回归到逻辑回归 线性回归的模型是求出输出特征向量Y和输入样本矩阵X之间的线性关系系数$θ$，满足$Y=Xθ$。此时我们的Y是连续的，所以是回归模型。 如果我们想要Y是离散的话, 一个可以想到的办法是，我们对于这个Y再做一次函数转换，变为$g(Y)$。如果我们令$g(Y)$的值在某个实数区间的时候是类别A，在另一个实数区间的时候是类别B，以此类推，就得到了一个分类模型。 2.二元逻辑回归的模型 逻辑回归的思想就是 在线性回归上再做一次函数转换，即上一节我们提到对线性回归的结果做一个在函数$g$上的转换，可以变化为逻辑回归。这个函数$g$在逻辑回归中我们一般取为sigmoid函数，形式如下： $$g(z)=\frac{1}{1+e^{-z}}$$ 图形如图： 它有一个非常好的性质，即当z趋于正无穷时，$g(z)$趋于1，而当$z$趋于负无穷时，$g(z)$趋于0，这非常适合于我们的分类概率模型。另外，它还有一个很好的导数性质： $$g^{`}(z)=g(z)(1-g(z))$$ 如果我们令$g(z)$中的$z$为：$z=xθ$，这样就得到了二元逻辑回归模型的一般形式：$$h_{\theta}(x)=\frac{1}{1+e^{\theta x}}$$ 其中$x$为样本输入，$hθ(x)$为模型输出，可以理解为某一分类的概率大小。而$θ$为分类模型的要求出的模型参数。 我们假设，如果$hθ(x)&gt;0.5$ ，即$xθ&gt;0$, 则$y$为1。如果$hθ(x)&lt;0.5$，即$xθ&lt;0$, 则$y$为0。 $y=0.5$是临界情况，此时$xθ=0$为， 从逻辑回归模型本身无法确定分类。 ——$hθ(x)$的值越小，而分类为0的的概率越高，反之，值越大的话分类为1的的概率越高。如果靠近临界点，则分类准确率会下降。 3.参数估计模型的数学形式确定后，剩下就是如何去求解模型中的参数。由于在线性回归模型中，输出$y$值是连续的，因此可以用差值的平方等表示损失函数。但是在回归中，输出$y$值是离散的，所以损失函数用极大似然法估计。 最大化似然函数 == 最小化损失函数 损失函数是似然函数求对数再取反 我们知道，按照二元逻辑回归的定义，假设我们的样本输出是0或1两类，那么我们有：$$P(y=1|x,\theta)=h_{\theta}(x)$$$$P(y=1|x,\theta)=1-h_{\theta}(x)$$把这两个式子写成一个式子，就是：$$P(y|x,\theta)=h_{\theta}(x)^y(1-h_{\theta}(x))^{1-y}$$其中y的取值只能是0或者1用矩阵法表示，即为：$$P(Y|X,\theta)=h_{\theta}(X)^Y(E-h_{\theta}(x))^{1-Y}$$其中E为单位矩阵。得到了y的概率分布函数表达式，我们就可以用似然函数最大化来求解我们需要的模型系数$\theta$.为了方便求解，这里我们用对数似然函数最大化，对数似然函数取反即为我们的损失函数$J(\theta)$.似然函数的代数表达式为：$$J(\theta)= -lnL(\theta) = -{\sum_{i=1}^m(y^{(i)}log(h_{\theta}(x^{(i)}))+(1-y^{(i)})log(1-h_{\theta}(x^{(i)})))}$$损失函数用矩阵法表达更加简洁：$$J(\theta)=- Y.logh_{\theta}(X)-(E-Y).log(E-h_{\theta}(X))$$这样，问题就转换成目标为最小化损失函数的优化问题，求解参数 4. 参数求解方法对于求解二元逻辑回归的损失函数极小化，有比较多的方法，最常见的有梯度下降法，坐标轴下降法，等牛顿法等。这里用梯度下降法中θ每次迭代的公式。（用矩阵的写法） 对于$J(\theta)=-Y.logh_{\theta}(X)-(1-Y).log(E-h_{\theta}(X))$,我们用$J(\theta)$对向量$\theta$向量求导得： $$\begin{align}\frac{\partial}{\partial \theta}J(\theta)=&amp;-YX^{T}\frac{1}{h_{\theta}(X)}h_{\theta}(X)(1-h_{\theta}(X))\\ &amp;+(E-Y)X^T\frac{1}{1-h_{\theta}(X)}h_{\theta}(X)(1-h_{\theta}(X))\end{align}$$这一步用到了矩阵求导的链式法则，和下面三个矩阵的求导公式： $\frac{\partial}{\partial X}logX=\frac{1}{X}$ $\frac{\partial}{\partial z}g(z)=g(z)(1-g(z))$ ($g(z)$为sigmoid函数) $\frac{\partial}{\partial \theta}X \theta= X^T(h_{\theta}(X)-Y)$ 从而在梯度下降法中每一步向量$ \theta $的迭代公式如下：$$\theta = \theta -\alpha X^T(h_{\theta}(X)-Y)$$其中，$ \alpha $为梯度下降法的步长 实践中，我们一般不用操心优化方法，大部分机器学习库都内置了各种逻辑回归的优化方法，不过了解至少一种优化方法还是有必要的。 5. 二元逻辑回归的正则化逻辑回归也会面临过拟合问题，所以我们也要考虑正则化。常见的有L1正则化和L2正则化 。二元逻辑回归的L1正则化损失函数表达式如下：$$J(\theta)=-Y.logh_{\theta}(X)-(E-Y).log(1-h_{\theta}(X))+\alpha||{\theta}||_1$$其中$\parallel{\theta}\parallel_1$ 为L1范数$$J(\theta)=-Y.logh_{\theta}(X)-(E-Y).log(1-h_{\theta}(X))+\alpha\parallel{\theta}\parallel_2^2$$其中$\parallel{\theta}\parallel_2^2$ 为L2范数两种正则化的特点L1正则化的模型建叫做Lasso回归，L1会趋向于产生少量的特征，而其他的特征都是0。Lasso在特征选择时候非常有用.L2正则化的模型叫做Ridge回归（岭回归）,L2会选择更多的特征，这些特征都会接近于0。这就只是一种规则化，防止过拟合。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优雅地使用latex编辑数学公式]]></title>
    <url>%2F2019%2F03%2F13%2Flatex%2F</url>
    <content type="text"><![CDATA[在写博客的过程中发现写数学公式是一件非常不友好的事情，不仅繁琐而且常出现兼容问题。 这里介绍一个非常强大的工具Latex，通过简单的语法可以轻松写出美观优雅的公式。本博文总结了一些Latex的基础语法，让你5分钟即可轻松上手。 1. 排版方式行级元素(inline)，行级元素使用$...$，在正文行内使用，两个$表示公式的首尾。 块级元素(displayed)，块级元素使用$$...$$，单独成行、自动居中。 2. 常用西文符号小写字母\alpha, \beta, …, \omega代表α,β,…ω. 大写字母,使用\Gamma, \Delta, …, \Omega代表Γ,Δ,…,Ω. 3. 上标与下标使用 ^ 和 _ 表示上标和下标. 例如,x_i^2:$x_i^2$ ，\log_2x:$\log_2x$ 使用{ }来保证优先级问题。例如要显示$10^{10}$,正确的语法应该是10^{10},若写成10^10则会显示成$10^10$。 4. 括号小括号和中括号直接使用，大括号由于因为用来表示优先级，所以需要转义。\{1+2\}:${1+2}$ 5. 运算 分数：\frac{}{},例如，\frac{1+1}{2}+1: $\frac{1+1}{2}+1$ 求和：\sum_1^n: $\sum_1^n$ 连乘：\prod_1^n: $\prod_1^n$ 积分：\int_1^n: $\int_1^n$ 极限：\lim_{x \to \infty}: $\lim_{x \to \infty}$ 矩阵：$$\begin{matrix}…\end{matrix}$$，使用&amp;分隔同行元素，\换行。例如：\begin{matrix}1 &amp; x &amp; x^2 \\1 &amp; y &amp; y^2 \\1 &amp; z &amp; z^2 \\\end{matrix},则显示为：$$\begin{matrix}1 &amp; x &amp; x^2 \\1 &amp; y &amp; y^2 \\1 &amp; z &amp; z^2 \\\end{matrix}$$ 6. 顶标与底标 角号：\hat{a}: $\hat{a}$ 横线：\overline{a}: $\overline{a}$ 箭头：\stackrel{\rightarrow}{a}: $\stackrel{\rightarrow}{a}$ 7. 集合关系 属于：\in: $\in$ 不属于：\not\in: $\not\in$ 包含于：A\subset B: $A\subset B$ 不包含于：A\not\subset B: $A\not\subset B$ 交：A\cap B: $A\cap B$ 并：A\cup B: $A\cup B$ 空集：\emptyset: $\emptyset$ 8. 例子h(\theta)=\sum_{j=0}^n \theta_jx_j$$h(\theta)=\sum_{j=0}^n \theta_jx_j$$ J(\theta)=\frac1{2m}\sum_{i=0}(y^i-h_\theta(x^i))^2$$J(\theta)=\frac1{2m}\sum_{i=0}(y^i-h_\theta(x^i))^2$$ 12345f(n) = \begin&#123;cases&#125; n/2, &amp; \text&#123;if $n$ is even&#125; \\\\ 3n+1, &amp; \text&#123;if $n$ is odd&#125; \end&#123;cases&#125; $$f(n) = \begin{cases} n/2, &amp; \text{if $n$ is even} \\ 3n+1, &amp; \text{if $n$ is odd} \end{cases}$$ 其中在hexo 中换行要用四个\\\\，并且与公式隔一个空格。用&amp;表示对齐。123456\begin&#123;align&#125;\frac&#123;\partial J(\theta)&#125;&#123;\partial\theta_j&#125;&amp; = -\frac1m\sum_&#123;i=0&#125;^m(y^i-h_\theta(x^i)) \frac&#123;\partial&#125;&#123;\partial\theta_j&#125;(y^i-h_\theta(x^i))\\\\&amp; = -\frac1m\sum_&#123;i=0&#125;^m(y^i-h_\theta(x^i)) \frac&#123;\partial&#125;&#123;\partial\theta_j&#125;(\sum_&#123;j=0&#125;^n\theta_jx_j^i-y^i)\\\\&amp; = -\frac1m\sum_&#123;i=0&#125;^m(y^i-h_\theta(x^i))x^i_j\end&#123;align&#125; $$\begin{align}\frac{\partial J(\theta)}{\partial\theta_j}&amp; = -\frac1m\sum_{i=0}^m(y^i-h_\theta(x^i)) \frac{\partial}{\partial\theta_j}(y^i-h_\theta(x^i))\\&amp; = -\frac1m\sum_{i=0}^m(y^i-h_\theta(x^i)) \frac{\partial}{\partial\theta_j}(\sum_{j=0}^n\theta_jx_j^i-y^i)\\&amp; = -\frac1m\sum_{i=0}^m(y^i-h_\theta(x^i))x^i_j\end{align}$$ 附录latex常用符号大全]]></content>
      <categories>
        <category>善其事利其器</category>
      </categories>
  </entry>
</search>
