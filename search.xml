<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机器学习笔记之逻辑回归原理</title>
      <link href="/2019/03/14/logistic-fundamental/"/>
      <url>/2019/03/14/logistic-fundamental/</url>
      
        <content type="html"><![CDATA[<h2 id="1-从线性回归到逻辑回归"><a href="#1-从线性回归到逻辑回归" class="headerlink" title="1.从线性回归到逻辑回归"></a>1.从线性回归到逻辑回归</h2><p>　　线性回归的模型是求出输出特征向量Y和输入样本矩阵X之间的线性关系系数$θ$，满足$Y=Xθ$。此时我们的Y是连续的，所以是回归模型。<br>    如果我们想要Y是离散的话, 一个可以想到的办法是，我们对于这个Y再做一次函数转换，变为$g(Y)$。如果我们令$g(Y)$的值在某个实数区间的时候是类别A，在另一个实数区间的时候是类别B，以此类推，就得到了一个分类模型。<br><a id="more"></a></p><h2 id="2-二元逻辑回归的模型"><a href="#2-二元逻辑回归的模型" class="headerlink" title="2.二元逻辑回归的模型"></a>2.二元逻辑回归的模型</h2><p>　　　逻辑回归的思想就是 在线性回归上再做一次函数转换，即上一节我们提到对线性回归的结果做一个在函数$g$上的转换，可以变化为逻辑回归。这个函数$g$在逻辑回归中我们一般取为<code>sigmoid</code>函数，形式如下：<br>   $$g(z)=\frac{1}{1+e^{-z}}$$</p><p>　　图形如图：<br>   <img src="http://po8vd3g8o.bkt.clouddn.com/20190314_1_sigmoid.png" width="50%" height="50%"></p><p>　它有一个非常好的性质，即当z趋于正无穷时，$g(z)$趋于1，而当$z$趋于负无穷时，$g(z)$趋于0，这非常适合于我们的分类概率模型。另外，它还有一个很好的导数性质：<br>    $$g^{`}(z)=g(z)(1-g(z))$$</p><p>如果我们令$g(z)$中的$z$为：$z=xθ$，这样就得到了二元逻辑回归模型的一般形式：<br>$$h_{\theta}(x)=\frac{1}{1+e^{\theta x}}$$</p><p>　　其中$x$为样本输入，$hθ(x)$为模型输出，可以理解为某一分类的概率大小。而$θ$为分类模型的要求出的模型参数。<br>      我们假设，如果$hθ(x)&gt;0.5$ ，即$xθ&gt;0$, 则$y$为1。如果$hθ(x)&lt;0.5$，即$xθ&lt;0$, 则$y$为0。 $y=0.5$是临界情况，此时$xθ=0$为， 从逻辑回归模型本身无法确定分类。</p><p>　　——$hθ(x)$的值越小，而分类为0的的概率越高，反之，值越大的话分类为1的的概率越高。如果靠近临界点，则分类准确率会下降。</p><h2 id="3-参数估计"><a href="#3-参数估计" class="headerlink" title="3.参数估计"></a>3.参数估计</h2><p>模型的数学形式确定后，剩下就是如何去求解模型中的参数。<br>由于在线性回归模型中，输出$y$值是连续的，因此可以用差值的平方等表示损失函数。但是在回归中，输出$y$值是离散的，所以损失函数用<strong>极大似然法估计</strong>。</p><ul><li>最大化似然函数    ==   最小化损失函数</li><li><p>损失函数是似然函数求对数再取反</p><p>我们知道，按照二元逻辑回归的定义，假设我们的样本输出是0或1两类，那么我们有：<br>$$P(y=1|x,\theta)=h_{\theta}(x)$$$$P(y=1|x,\theta)=1-h_{\theta}(x)$$把这两个式子写成一个式子，就是：$$P(y|x,\theta)=h_{\theta}(x)^y(1-h_{\theta}(x))^{1-y}$$其中y的取值只能是0或者1<br>用矩阵法表示，即为：$$P(Y|X,\theta)=h_{\theta}(X)^Y(E-h_{\theta}(x))^{1-Y}$$其中E为单位矩阵。<br>得到了y的概率分布函数表达式，我们就可以用似然函数最大化来求解我们需要的模型系数$\theta$.<br>为了方便求解，这里我们用对数似然函数最大化，对数似然函数取反即为我们的损失函数$J(\theta)$.<br>似然函数的代数表达式为：<br>$$J(\theta)= -lnL(\theta) = -{\sum_{i=1}^m(y^{(i)}log(h_{\theta}(x^{(i)}))+(1-y^{(i)})log(1-h_{\theta}(x^{(i)})))}$$损失函数用矩阵法表达更加简洁：$$J(\theta)=- Y.logh_{\theta}(X)-(E-Y).log(E-h_{\theta}(X))$$这样，问题就转换成目标为最小化损失函数的优化问题，求解参数</p></li></ul><h2 id="4-参数求解方法"><a href="#4-参数求解方法" class="headerlink" title="4. 参数求解方法"></a>4. 参数求解方法</h2><p>对于求解二元逻辑回归的损失函数极小化，有比较多的方法，最常见的有梯度下降法，坐标轴下降法，等牛顿法等。这里用梯度下降法中θ每次迭代的公式。（用矩阵的写法）<br>  对于$J(\theta)=-Y.logh_{\theta}(X)-(1-Y).log(E-h_{\theta}(X))$,我们用$J(\theta)$对向量$\theta$向量求导得：<br>  $$\begin{align}\frac{\partial}{\partial \theta}J(\theta)=&amp;-YX^{T}\frac{1}{h_{\theta}(X)}h_{\theta}(X)(1-h_{\theta}(X))\\ &amp;+(E-Y)X^T\frac{1}{1-h_{\theta}(X)}h_{\theta}(X)(1-h_{\theta}(X))\end{align}$$这一步用到了矩阵求导的链式法则，和下面三个矩阵的求导公式：<br>  $\frac{\partial}{\partial X}logX=\frac{1}{X}$<br>  $\frac{\partial}{\partial z}g(z)=g(z)(1-g(z))$ ($g(z)$为sigmoid函数)<br>  $\frac{\partial}{\partial \theta}X \theta= X^T(h_{\theta}(X)-Y)$<br>  从而在梯度下降法中每一步向量$ \theta $的迭代公式如下：$$\theta = \theta -\alpha X^T(h_{\theta}(X)-Y)$$其中，$ \alpha $为梯度下降法的步长<br>  <img src="http://po8vd3g8o.bkt.clouddn.com/20190314_2_ient_descent.png" width="50%" height="50%"><br>  实践中，我们一般不用操心优化方法，大部分机器学习库都内置了各种逻辑回归的优化方法，不过了解至少一种优化方法还是有必要的。</p><h2 id="5-二元逻辑回归的正则化"><a href="#5-二元逻辑回归的正则化" class="headerlink" title="5. 二元逻辑回归的正则化"></a>5. 二元逻辑回归的正则化</h2><p>逻辑回归也会面临过拟合问题，所以我们也要考虑正则化。常见的有L1正则化和L2正则化 。<br>二元逻辑回归的L1正则化损失函数表达式如下：<br>$$J(\theta)=-Y.logh_{\theta}(X)-(E-Y).log(1-h_{\theta}(X))+\alpha||{\theta}||_1$$其中$\parallel{\theta}\parallel_1$ 为L1范数<br>$$J(\theta)=-Y.logh_{\theta}(X)-(E-Y).log(1-h_{\theta}(X))+\alpha\parallel{\theta}\parallel_2^2$$其中$\parallel{\theta}\parallel_2^2$ 为L2范数<br><strong>两种正则化的特点</strong><br>L1正则化的模型建叫做Lasso回归，L1会趋向于产生少量的特征，而其他的特征都是0。Lasso在特征选择时候非常有用.<br>L2正则化的模型叫做Ridge回归（岭回归）,L2会选择更多的特征，这些特征都会接近于0。这就只是一种规则化，防止过拟合。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优雅地使用latex编辑数学公式</title>
      <link href="/2019/03/13/latex/"/>
      <url>/2019/03/13/latex/</url>
      
        <content type="html"><![CDATA[<p>在写博客的过程中发现写数学公式是一件非常不友好的事情，不仅繁琐而且常出现兼容问题。 这里介绍一个非常强大的工具Latex，通过简单的语法可以轻松写出美观优雅的公式。<br>本博文总结了一些Latex的基础语法，让你5分钟即可轻松上手。  </p><a id="more"></a><h4 id="1-排版方式"><a href="#1-排版方式" class="headerlink" title="1. 排版方式"></a>1. 排版方式</h4><p>行级元素(inline)，行级元素使用<code>$...$</code>，在正文行内使用，两个$表示公式的首尾。</p><p>块级元素(displayed)，块级元素使用<code>$$...$$</code>，单独成行、自动居中。</p><h4 id="2-常用西文符号"><a href="#2-常用西文符号" class="headerlink" title="2. 常用西文符号"></a>2. 常用西文符号</h4><p>小写字母<code>\alpha</code>, <code>\beta</code>, …, <code>\omega</code>代表<code>α,β,…ω</code>. </p><p>大写字母,使用<code>\Gamma</code>, <code>\Delta</code>, …, <code>\Omega</code>代表<code>Γ,Δ,…,Ω</code>.</p><h4 id="3-上标与下标"><a href="#3-上标与下标" class="headerlink" title="3. 上标与下标"></a>3. 上标与下标</h4><p>使用 <code>^</code> 和 <code>_</code> 表示上标和下标. 例如,<code>x_i^2</code>:$x_i^2$ ，<code>\log_2x</code>:$\log_2x$</p><p>使用<code>{ }</code>来保证优先级问题。例如要显示$10^{10}$,正确的语法应该是<code>10^{10}</code>,若写成<code>10^10</code>则会显示成$10^10$。</p><h4 id="4-括号"><a href="#4-括号" class="headerlink" title="4. 括号"></a>4. 括号</h4><p>小括号和中括号直接使用，大括号由于因为用来表示优先级，所以需要转义。<code>\{1+2\}</code>:${1+2}$</p><h4 id="5-运算"><a href="#5-运算" class="headerlink" title="5. 运算"></a>5. 运算</h4><ul><li>分数：<code>\frac{}{}</code>,例如，<code>\frac{1+1}{2}+1</code>: 　$\frac{1+1}{2}+1$ <br></li><li>求和：<code>\sum_1^n</code>:　$\sum_1^n$ <br></li><li>连乘：<code>\prod_1^n</code>:　$\prod_1^n$ <br></li><li>积分：<code>\int_1^n</code>:　$\int_1^n$ <br></li><li>极限：<code>\lim_{x \to \infty}</code>:　$\lim_{x \to \infty}$</li><li>矩阵：<code>$$\begin{matrix}…\end{matrix}$$</code>，使用&amp;分隔同行元素，\换行。<br>例如：<code>\begin{matrix}1 &amp; x &amp; x^2 \\1 &amp; y &amp; y^2 \\1 &amp; z &amp; z^2 \\\end{matrix}</code>,则显示为：<br>$$\begin{matrix}1 &amp; x &amp; x^2 \\1 &amp; y &amp; y^2 \\1 &amp; z &amp; z^2 \\\end{matrix}$$</li></ul><h4 id="6-顶标与底标"><a href="#6-顶标与底标" class="headerlink" title="6. 顶标与底标"></a>6. 顶标与底标</h4><ul><li>角号：<code>\hat{a}</code>:　$\hat{a}$ <br></li><li>横线：<code>\overline{a}</code>:　$\overline{a}$ <br></li><li>箭头：<code>\stackrel{\rightarrow}{a}</code>:　$\stackrel{\rightarrow}{a}$ <br></li></ul><h4 id="7-集合关系"><a href="#7-集合关系" class="headerlink" title="7. 集合关系"></a>7. 集合关系</h4><ul><li>属于：<code>\in</code>:　$\in$ </li><li>不属于：<code>\not\in</code>:　$\not\in$ </li><li>包含于：<code>A\subset B</code>:　$A\subset B$ </li><li>不包含于：<code>A\not\subset B</code>:　$A\not\subset B$ </li><li>交：<code>A\cap B</code>:　$A\cap B$ </li><li>并：<code>A\cup B</code>:　$A\cup B$ </li><li>空集：<code>\emptyset</code>:　$\emptyset$ </li></ul><h4 id="8-例子"><a href="#8-例子" class="headerlink" title="8. 例子"></a>8. 例子</h4><p><code>h(\theta)=\sum_{j=0}^n \theta_jx_j</code><br>$$h(\theta)=\sum_{j=0}^n \theta_jx_j$$  </p><p><code>J(\theta)=\frac1{2m}\sum_{i=0}(y^i-h_\theta(x^i))^2</code><br>$$J(\theta)=\frac1{2m}\sum_{i=0}(y^i-h_\theta(x^i))^2$$ </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(n) =</span><br><span class="line">    \begin&#123;cases&#125;</span><br><span class="line">    n/2,  &amp; \text&#123;if $n$ is even&#125; \\\\</span><br><span class="line">    3n+1, &amp; \text&#123;if $n$ is odd&#125;</span><br><span class="line">    \end&#123;cases&#125;</span><br></pre></td></tr></table></figure><p>$$<br>f(n) =<br>    \begin{cases}<br>    n/2,  &amp; \text{if $n$ is even} \\<br>    3n+1, &amp; \text{if $n$ is odd}<br>    \end{cases}<br>$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;align&#125;</span><br><span class="line">\frac&#123;\partial J(\theta)&#125;&#123;\partial\theta_j&#125;</span><br><span class="line">&amp; = -\frac1m\sum_&#123;i=0&#125;^m(y^i-h_\theta(x^i)) \frac&#123;\partial&#125;&#123;\partial\theta_j&#125;(y^i-h_\theta(x^i))\\\\</span><br><span class="line">&amp; = -\frac1m\sum_&#123;i=0&#125;^m(y^i-h_\theta(x^i)) \frac&#123;\partial&#125;&#123;\partial\theta_j&#125;(\sum_&#123;j=0&#125;^n\theta_jx_j^i-y^i)\\\\</span><br><span class="line">&amp; = -\frac1m\sum_&#123;i=0&#125;^m(y^i-h_\theta(x^i))x^i_j</span><br><span class="line">\end&#123;align&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>\frac{\partial J(\theta)}{\partial\theta_j}<br>&amp; = -\frac1m\sum_{i=0}^m(y^i-h_\theta(x^i)) \frac{\partial}{\partial\theta_j}(y^i-h_\theta(x^i))\\<br>&amp; = -\frac1m\sum_{i=0}^m(y^i-h_\theta(x^i)) \frac{\partial}{\partial\theta_j}(\sum_{j=0}^n\theta_jx_j^i-y^i)\\<br>&amp; = -\frac1m\sum_{i=0}^m(y^i-h_\theta(x^i))x^i_j<br>\end{align}<br>$$</p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p>latex常用符号大全</p><center><br><img src="https://img2018.cnblogs.com/blog/1546465/201812/1546465-20181205141235485-1222147689.png" width="70%" height="70%"><br></center><center><br><img src="https://img2018.cnblogs.com/blog/1546465/201812/1546465-20181205141741443-1816768474.png" width="70%" height="70%"><br></center><center><br><img src="https://img2018.cnblogs.com/blog/1546465/201812/1546465-20181205141821513-841164644.png" width="70%" height="70%"><br></center><center><br><img src="https://img2018.cnblogs.com/blog/1546465/201812/1546465-20181205141829893-1398611654.png" width="70%" height="70%"><br></center><center><br><img src="https://img2018.cnblogs.com/blog/1546465/201812/1546465-20181205141838019-676809356.png" width="70%" height="70%"><br></center><center><br><img src="https://img2018.cnblogs.com/blog/1546465/201812/1546465-20181205141848243-4523055.png" width="70%" height="70%"><br></center>]]></content>
      
      
      <categories>
          
          <category> 善其事利其器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据可视化之Matplotlib:Pandas中的绘图函数</title>
      <link href="/2019/03/13/20190313-python-pandas-matplotlib/"/>
      <url>/2019/03/13/20190313-python-pandas-matplotlib/</url>
      
        <content type="html"><![CDATA[<p>Pandas有许多能够利用DataFrame对象数据组织特点来创建标准图表的高级绘图方法，本文主要介绍的是pandas中的绘图函数。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame,Series</span><br></pre></td></tr></table></figure><h3 id="1-线形图"><a href="#1-线形图" class="headerlink" title="1. 线形图"></a>1. 线形图</h3><p>&emsp;<code>df.plot( kind=&#39;line&#39;)</code></p><ul><li>Series 的plot 方法会以index作为X轴,画一条线</li><li>DataFrame 的plot 方法会以index作为X轴，给每一列绘制一条线,columns作为图例。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第一种创建画布和画布分区方法，分开创建figure和subplot对象</span></span><br><span class="line">fig=plt.figure()</span><br><span class="line"><span class="comment">#Series 的线形图</span></span><br><span class="line">ax1=fig.add_subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">s=Series(np.random.rand(<span class="number">10</span>).cumsum(),index=np.arange(<span class="number">0</span>,<span class="number">100</span>,<span class="number">10</span>))  </span><br><span class="line">s.plot( kind=<span class="string">'line'</span>)</span><br><span class="line">plt.xlabel(<span class="string">u"index"</span>) </span><br><span class="line">plt.title(<span class="string">u"Serise的线形图"</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment">#DataFrame的线形图</span></span><br><span class="line">ax2=fig.add_subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">df=DataFrame(np.random.rand(<span class="number">10</span>,<span class="number">4</span>).cumsum(<span class="number">0</span>),index=np.arange(<span class="number">0</span>,<span class="number">100</span>,<span class="number">10</span>),columns=pd.Index([<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>],name=<span class="string">'Genus'</span>))</span><br><span class="line">df.plot( kind=<span class="string">'line'</span>)</span><br><span class="line">plt.xlabel(<span class="string">u"index"</span>) </span><br><span class="line">plt.title(<span class="string">u"DataFrame的线形图"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img2018.cnblogs.com/blog/1546465/201812/1546465-20181204163748429-1417188412.png" alt></p><p><img src="https://img2018.cnblogs.com/blog/1546465/201812/1546465-20181204163757284-680543910.png" alt></p><p>其中，Series.plot方法的参数<br></p><ul><li>kind      ：图的类型，‘line’,’bar’,’barh’,’kde’</li><li>label     ：图例标签</li><li>ax        ：需要绘制的对象</li><li>rot        ：旋转角度</li><li>xticks    ：X轴刻度值</li><li>xlim        ：X轴刻度范围</li><li>grid        ：显示网格</li></ul><h3 id="2-柱状图"><a href="#2-柱状图" class="headerlink" title="2. 柱状图"></a>2. 柱状图</h3><p>&emsp;<code>df.plot( kind=&#39;bar&#39;)</code> : 垂直柱状图</p><p>&emsp;<code>df.plot( kind=&#39;barh&#39;)</code> : 水平柱状图</p><p>&emsp;<code>df.plot( kind=&#39;bar&#39;,stacked=True)</code> : stacked属性为True可以设置为堆积柱状图</p><h4 id="Series的柱状图"><a href="#Series的柱状图" class="headerlink" title="Series的柱状图"></a>Series的柱状图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第二种创建画布和画布分区方法，创建figure，返回一个subplot对象</span></span><br><span class="line">fig,axes =plt.subplots(<span class="number">2</span>,<span class="number">1</span>)             </span><br><span class="line">s=Series(np.random.rand(<span class="number">16</span>),index=list(<span class="string">'abcdefghijklmnop'</span>))  </span><br><span class="line">s.plot( kind= <span class="string">'bar'</span> ,ax=axes[<span class="number">0</span>])       <span class="comment">#返回的axes的数组可指定在哪个subplot对象上画图</span></span><br><span class="line">s.plot( kind= <span class="string">'barh'</span> ,ax=axes[<span class="number">1</span>])      </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img2018.cnblogs.com/blog/1546465/201812/1546465-20181204163812452-87703054.png" alt></p><h4 id="DataFrame的柱状图"><a href="#DataFrame的柱状图" class="headerlink" title="DataFrame的柱状图"></a>DataFrame的柱状图</h4><ul><li>每一行的值为一组，每一列的columns为图例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig,axes =plt.subplots(<span class="number">2</span>,<span class="number">1</span>)                    </span><br><span class="line">df=DataFrame(np.random.rand(<span class="number">4</span>,<span class="number">4</span>),index=[<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>,<span class="string">'four'</span>],columns=pd.Index([<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>],name=<span class="string">'Genus'</span>))  </span><br><span class="line">df.plot( kind= <span class="string">'bar'</span>,ax=axes[<span class="number">0</span>] )             </span><br><span class="line">df.plot( kind= <span class="string">'bar'</span>,ax=axes[<span class="number">1</span>],stacked=<span class="literal">True</span> )  <span class="comment">#stacked=True 可以生成堆积柱状图</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img2018.cnblogs.com/blog/1546465/201812/1546465-20181204163822611-1554001201.png" alt></p><h3 id="3-密度图-KDE-Kernel-Density-Estimate-核密度估计"><a href="#3-密度图-KDE-Kernel-Density-Estimate-核密度估计" class="headerlink" title="3.密度图( KDE, Kernel Density Estimate ,核密度估计 )"></a>3.密度图( KDE, Kernel Density Estimate ,核密度估计 )</h3><ul><li>密度图即为连续概率分布图，将分布近似为标准混合正态分布。</li></ul><p>&emsp;<code>df.plot( kind=&#39;kde&#39;)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fig=plt.figure()</span><br><span class="line"><span class="comment">#Series 的密度图</span></span><br><span class="line">fig.add_subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">s=Series(np.random.rand(<span class="number">50</span>).cumsum(),index=np.arange(<span class="number">0</span>,<span class="number">100</span>,<span class="number">2</span>))  </span><br><span class="line">s.plot(kind=<span class="string">'kde'</span>)</span><br><span class="line">plt.title(<span class="string">u"Series的密度图"</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#DataFrame 的密度图，会给每一列都画一条密度估计线，并将columns自动生成图例</span></span><br><span class="line">fig.add_subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">df=DataFrame(np.random.rand(<span class="number">10</span>,<span class="number">4</span>).cumsum(<span class="number">0</span>),index=np.arange(<span class="number">0</span>,<span class="number">100</span>,<span class="number">10</span>),columns=pd.Index([<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>],name=<span class="string">'Genus'</span>))</span><br><span class="line">df.plot(kind=<span class="string">'kde'</span>)</span><br><span class="line">plt.title(<span class="string">u"DataFrame的密度图"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img2018.cnblogs.com/blog/1546465/201812/1546465-20181204163832623-1229598751.png" alt></p><p><img src="https://img2018.cnblogs.com/blog/1546465/201812/1546465-20181204163840293-1288670008.png" alt></p><h3 id="4-直方图"><a href="#4-直方图" class="headerlink" title="4.直方图"></a>4.直方图</h3><ul><li>直方图是对值频率进行离散化显示的柱状图，数据点呗拆分到离散的、间隔均匀的面元中。</li></ul><p>&emsp;<code>df.hist( bins=10)</code>     :bins属性可设置柱子数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fig=plt.figure()</span><br><span class="line"><span class="comment">#Series 的密度图</span></span><br><span class="line">fig.add_subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">s=Series(np.random.rand(<span class="number">20</span>).cumsum(),index=np.arange(<span class="number">0</span>,<span class="number">100</span>,<span class="number">5</span>))  </span><br><span class="line">s.hist( bins=<span class="number">10</span>)</span><br><span class="line">plt.title(<span class="string">u"Series的直方图"</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#DataFrame 的密度图，会给每一列都画一张直方图，并将列名作为对应标题</span></span><br><span class="line">fig.add_subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">df=DataFrame(np.random.rand(<span class="number">10</span>,<span class="number">4</span>).cumsum(<span class="number">0</span>),index=np.arange(<span class="number">0</span>,<span class="number">100</span>,<span class="number">10</span>),columns=pd.Index([<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>],name=<span class="string">'Genus'</span>))</span><br><span class="line">df.hist( bins=<span class="number">10</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img2018.cnblogs.com/blog/1546465/201812/1546465-20181204163900618-458380905.png" alt></p><p><img src="https://img2018.cnblogs.com/blog/1546465/201812/1546465-20181204163909003-1922957566.png" alt></p><h3 id="5-散点图"><a href="#5-散点图" class="headerlink" title="5.散点图"></a>5.散点图</h3><ul><li>散点图是观察两个一维数据间关系的有效方式</li></ul><p>&emsp;<code>plt.scatter(X,Y)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">macro = pd.read_csv(<span class="string">'macrodata.csv'</span>)</span><br><span class="line">data = macro[[<span class="string">'cpi'</span>,<span class="string">'m1'</span>,<span class="string">'tbilrate'</span>,<span class="string">'unemp'</span>]]</span><br><span class="line">trans_data = np.log(data).diff().dropna()</span><br><span class="line"><span class="comment"># 画出两个Series之间的散点图</span></span><br><span class="line">plt.scatter(trans_data[<span class="string">'m1'</span>],trans_data[<span class="string">'unemp'</span>])</span><br><span class="line">plt.title(<span class="string">'Change in log %s vs.log %s'</span> % (<span class="string">'m1'</span>,<span class="string">'unemp'</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img2018.cnblogs.com/blog/1546465/201812/1546465-20181204163918343-2072736584.png" alt></p><h4 id="DataFrame的散点图矩阵"><a href="#DataFrame的散点图矩阵" class="headerlink" title="DataFrame的散点图矩阵"></a>DataFrame的散点图矩阵</h4><ul><li><p>创建散布图矩阵，会把DataFrame中任意两列画散点图，观察其之间的关系。</p></li><li><p>支持在对角线上放置各变量的直方图或者密度图</p></li></ul><p>&emsp;<code>pd.scatter_matrix( trans_data ,diagonal = &#39;kde&#39; ,color =&#39;k&#39; ,alpha=0.3)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 画出散布图矩阵</span></span><br><span class="line">pd.plotting.scatter_matrix( trans_data ,diagonal = <span class="string">'kde'</span> ,color =<span class="string">'k'</span> ,alpha=<span class="number">0.3</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img2018.cnblogs.com/blog/1546465/201812/1546465-20181204163931304-296265717.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据可视化 </tag>
            
            <tag> matplotlib </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
